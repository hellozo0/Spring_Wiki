## Section 01 & 02 타임리프

> 타임리프의 특징을 JSP와 비교하며 설명하세요.

타임리프는 서버 사이드 HTML 렌더링(SSR)에 사용되는 언어입니다.
JSP와 달리 순수 HTML을 최대한 유지하는 특징이 있어 웹 브라우저에서 파일을 직접 열어 내용을 확인할 수도 있고, 서버를 통해 동적으로 변경될 수 있습니다.
이렇듯 순수 HTML을 그대로 유지하면서 뷰 템플릿도 사용할 수 있는 템플릿을 Natural Template이라고 합니다.

> 타임리프의 기본 표현식에는 어떤 것들이 있나요? (텍스트, 변수, 기본 객체, 유틸리티 객체와 날짜, 링크, 리터럴, 연산, 반복, 조건부 평가, 주석, 블록 등 간단히 서술해보기)

- 변수 표현식: `${...}`
- 선택 변수 표현식: `*{...}`
- 메시지 표현식: `#{...}`
- 링크 URL 표현식: `@{...}`
- 조각 표현식: `~{...}`
...

<br>

## Section 03 메시지, 국제화
> 메시지 기능이란 무엇이고 어떻게 구현할 수 있나요?

서버 전반의 다양한 메시지를 한 곳에서 관리하는 기능을 말한다.
`messages.properties`라는 메시지 관리용 파일을 만들어 메시지를 관리하고, 각 메시지 데이터를 key 값으로 불러 사용할 수 있다.

<br>

> 국제화 기능이란 무엇이고 어떻게 구현할 수 있나요?

각 메시지를 각 나라별로 별도로 관리해 서비스를 국제화하는 것을 말한다. `messages_ko.properties`, `messages_en.properties` 등 messages 뒤에 나라의 약자를 붙여 사용할 수 있다.

<br>

> 국제화 기능은 어떤 방식을 통해 `Locale` 선택 방식을 변경하나요?

HTTP의 `accept-language` 헤더 값을 사용하거나 사용자가 직접 언어를 선택하도록 하고, 쿠키 등을 사용해 처리한다.

<br>

<br>

## Section 04 검증1
> `BindingResult`가 쓰이는 방법에 대해 설명하세요.

`BindingResult`에 검증 오류 내용을 보관하면 타임리프에서 활용할 수 있다.

<br>

> 스프링의 `MessageCodesResolver`는 오류 코드를 어떤 전략으로 관리하나요?

`MessageCodesResolver`는 검증 오류 코드로 메시지 코드들을 생성하는 스프링 빈입니다.
객체 오류의 경우 다음 순서로 2가지 메시지를 생성합니다.
1. code + "." + object name
2. code

필드 오류의 경우 다음 순서로 4가지 메시지를 생성합니다.
1. code + "." + object name + "." + field
2. code + "." + field
3. code + "." + field type
4. code

<br>

> `@Validated`와 `@Valid`의 차이점은 무엇인가요?

둘다 빈을 검증하는 어노테이션이지만 `@Validated`는 스프링 전용 검증 어노테이션이고, `@Valid`는 자바 표준 검증 어노테이션이다. `@Validated`는 BeanValidation의 groups 기능으로 등록 시 검증할 기능, 수정 시 검증할 기능을 각 그룹으로 나누어 적용할수 있다.

<br>

<br>

## Section 05 검증2
> `@ModelAttribute`로 클래스가 넘어왔을 때,  각각의 필드에 타입 변환 시도, typeMismatch, Validator 적용이 어떤 순서로 이루어지는지 설명하세요.

1. 각각의 필드에 타입 변환 시도
2. 성공하면 다음으로, 실패하면 `typeMismatch`로 `FieldError` 추가
3. Validator 적용

<br>

> Bean Validation이란 무엇인가요?

Bean Validation 2.0(JSR-380)이라는 기술 표준으로, 검증 애노테이션과 여러 인터페이스의 모음입니다. Bean Validation을 구현한 기술 중에는 하이버네이트 Validator가 있습니다.

<br>

> 자주 쓰이는 검증 애노테이션의 종류를 설명해주세요.

- `@NotBlank` : 빈값 + 공백만 있는 경우를 허용하지 않는다.
- `@NotNull` : null을 허용하지 않는다.
- `@Range(min = 1000, max = 1000000)` : 범위 안의 값이어야 한다.
- `@Max(9999)` : 최대 9999까지만 허용한다.

<br>

<br>

## Section 06 로그인 처리1 - 쿠키, 세션
> 도메인이란 무엇일까요?

화면, UI, 기술 인프라 등등의 영역은 제외한 시스템이 구현해야 하는 핵심 비즈니스 업무 영역을 말한다. 향후 web을 다른 기술로 바꾸어도 도메인은 그대로 유지할 수 있어야 한다. 이렇게 하려면 web은 domain을 알 고 있지만, domain은 web을 모르도록 설계해야 한다. 즉, web은 domain을 의존하지만, domain은 web을 의존하지 않아야 한다.

<br>

> 쿠키의 종류 2가지(영속 쿠키, 세션 쿠키)에 대해 설명해보세요.

- 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지된다.
- 세션 쿠키: 만료 날짜를 생략하면 브라우저가 종료할 때까지만 유지된다.

<br>

> 쿠키를 사용해 로그인 ID를 전달 할 때 발생할 수 있는 보안 문제에 대해 설명하고 이 대안을 고민해보세요.

발생할 수 있는 보안 문제는 다음과 같다.
1. 쿠키 값은 임의로 변경할 수 있다.
2. 쿠키에 보관된 정보는 훔쳐갈 수 있다.
3. 해커가 쿠키를 한번 훔쳐가면 평생 사용할수 있다.

대안은 다음과 같다.
1. 쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의 토큰을 노출하며 토큰과 사용자 ID를 매핑해 인식한다. 그리고 서버에서 토큰을 관리한다.
2. 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능해야 한다.
3. 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게 유지한다. 또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다.

<br>

> 세션과 `HttpSession`이란 무엇인가요?

서버에 중요한 정보를 보관하고 연결을 유지하는 방법을 세션이라고 한다. `HttpSession`은 서블릿이 공식적으로 제공하는 세션이다.

<br>

> `@SessionAttribute` 애노테이션은 어떤 기능을 제공하나요?

스프링이 세션을 더 편리하게 사용할 수 있도록 지원하는 기능이다. 파라미터에서 사용하면 세션을 찾고 세션에 들어있는 데이터를 찾는 번거로운 과정을 한번에 편리하게 처리해준다.

<br>

> 세션 종료 시점은 어떻게 정하면 좋을까요?

세션은 사용자가 로그아웃을 직접 호출해서 `session.invalidate()`가 호출 되는 경우에 삭제된다. 그런데 대부분 사용자는 로그아웃을 선택하지 않고 그냥 웹 브라우저를 종료한다. 이 경우 남아있는 세션을 무한정 보관하면 쿠키를 탈취당했을 경우 해당 쿠키로 오랜 시간 악의적인 요청이 들어올 수 있고, 많은 세션이 생성되어 메모리에 한계가 올 수 있다.

이 대안으로 세션의 종료 시점을 설정해야 하는데, 사용자가 서버에 최근 요청한 시간을 기준으로 30분 정도를 유지해주는 것이 적합하다. `HttpSession`은 이 방식을 사용한다.

<br>

<br>

## Section 07 로그인 처리2 - 필터, 인터셉터
> 필터의 흐름과 특징에 대해 설명해보세요.

흐름: HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러

특징
- 체인으로 구성되어 있어 중간에 필터를 자유롭게 추가할 수 있다.
예) 모든 고객의 요청 로그를 남기는 요구사항이 있으면 필터를 사용하면 된다.

<br>

> 스프링 인터셉터의 흐름과 특징에 대해 설명해보자.

서블릿 필터와 같이 웹과 관련된 공통 관심 사항을 효과적으로 해결할 수 있는 기술이다.
서블릿 필터는 서블릿이 제공하는 기술이라면, 스프링 인터셉터는 스프링 MVC가 제공하는 기술이다. 서로 적용되는 순서와 범위, 사용방법이 다르다.

<br>

<br>

## Section 08 예외 처리와 오류 페이지
> 서블릿이 예외 처리를 지원하는 2가지 방식에 대해 설명해보세요.

1. 'Exception'(예외)를 던지고 try ~ catch 문으로 예외를 잡아 처리하지 않으면 WAS까지 예외가 전달되어 500 에러를 발생시킨다. 
2. 'response.sendError(HTTP 상태 코드, 오류 메시지)'로 오류 메시지와 원하는 상태코드의 에러를 발생시킬 수 있다.

<br>

> 서블릿은 클라이언트로부터 발생한 정상 요청인지, 오류 페이지를 위한 내부 요청인지 어떻게 구분하나요?

필터가 요청 종류를 구분할 수 있도록 'DispatcherType' 옵션을 제공한다. 고객이 처음 요청하면 REQUEST, 오류 페이지 요청이면 ERROR 상태값을 가진다.

<br>

> 커스텀 에러 페이지는 어떻게 등록할 수 있으며 등록 시 부여되는 우선순위 규칙에 대해 설명해주세요.

예외 종류마다 ErrorPage를 만들고 WebServerCustomizer와 ErrorPageController을 만들어야 한다. 
그러나 스프링 부트는 이 과정을 기본적으로 설정해준다. 
'/error' 경로로 기본 오류 페이지를 설정하고, BasicErrorController라는 스프링 컨트롤러를 등록한다.

<br>
    
<br>

## Section 09 API 예외처리
> `HandlerExceptionResolver`의 반환 값에 따른 `DispatcherServlet`의 동작 방식을 설명해주세요.

스프링 MVC는 컨트롤러 외부로 던져진 예외를 해결하고, 동작 방식을 변경하고 싶을 때 'HandlerExceptionResolver'를 제공한다.
ExceptionResolver가 반환하는 ModelAndView 값에 따라 DispatcherServlet은 다음과 같이 행동한다.
- 빈 ModelAndView: 뷰를 렌더링하지 않고 정상 흐름으로 서블릿이 리턴된다.
- ModelAndView 지정: ModelAndView에 View와 Model 등의 정보를 지정해 변환하면 뷰를 렌더링한다.
- null: 다른 ExceptionResolver를 찾아 실행한다. 만일 더 이상 ExceptioResolver가 없다면 예외 처리가 안 되고 기존에 발생한 예외를 밖으로 던진다.

<br>

> `ExceptionResolver`는 어떤 상황에 활용할 수 있을까요?

1. 예외 상태 코드 변환
2. 뷰 템플릿 처리(예외에 따른 새로운 오류 화면을 뷰 렌더링한다.)
3. API 응답 처리(에러에 따라 HTTP 응답에 바디를 넣어주는 것도 가능하다.)

<br>

> 스프링이 제공하는 `ExceptionResolver` 종류 3가지에 대해 자세히 설명해주세요.

1. ExceptionHandlerExceptionResolver
'@ExceptionHandler'를 처리한다.

2. ResponseStatusExceptionResolver
Http 상태 코드를 지정해준다. (@ResponseStatus)

3. DefaultHandlerExceptionResolver
스프링 내부 기본 예외를 처리한다.


<br>

> `@ControllerAdvice`는 어떤 역할의 어노테이션인가요?

대상으로 지정한 여러 컨트롤러에 '@ExceptionHandler' '@InitBinder' 기능을 부여해주는 역할을 한다.

<br>
    
<br>

## Section 10 스프링 타입 컨버터
> 스프링의 `ConversionService`는 어떤 기능을 제공하나요?

타입 컨버터를 하나하나 직접 찾아서 타입 변환에 사용하는 것은 매우 불편하다. 그래서 스프링은 ConversionService로 개별 컨버터를 모아두고 그것들을 묶어서 편리하게 사용할 수 있도록 도와준다.

<br>

> `Converter`와 `Formatter`의 차이를 설명해주세요.

Converter는 객체에서 객체로 변환할 때, 즉 범용적으로 사용된다. Formatter는 객체에서 문자, 또는 문자에서 객체로 변환하는 특수한 목적으로 사용된다.

<br>

> 스프링에서 애노테이션 기반으로 지원하는 포맷터 두 가지를 설명해주세요.

- '@NumberFormat' : 숫자 관련 형식 지정
- '@DatetimeFormat' : 날짜 관련 형식 지정

<br>

<br>

## Section 11 파일 업로드
> 문자와 바이너리(첨부파일)를 동시에 전송해야 할 때 사용하는 전송 방식은 무엇인가요? 자세히 설명해주세요.

HTTP의 'multipart/form-data' 전송 방식을 사용한다.
다른 종류의 여러 파일과 폼 내용을 함께 전송할 수 있다.

<br>

> 서블릿이 제공하는 `Part`는 어떤 역할을 수행하나요?

multipart로 전송되는 데이터들은 'Part'로 부분부분 나뉘어 복잡하게 전달된다.
서블릿이 제공하는 Part는 멀티파트 형식을 편리하게 읽을 수 있는 여러 메서드를 제공한다.

