### Section 01 JPA 소개
> ORM이란 무엇인가요?

ORM은 Object-Relational Mapping(객체 관계 매핑)의 약자로 객체는 객체대로, 관계형 데이터베이스는 관계형 데이터베이스 대로 설계하면 중간에서 객체와 관계형 데이터베이스를 매핑하는 프레임워크 기술을 말한다. 

<br>

> JPA란 무엇인가요? 왜 사용하셨나요?

JPA는 Java Persistence API로 자바 진형의 표준 ORM 기술이다.
JPA를 사용하면 SQL 중심적인 개발에서 객체 중심적인 개발로 발전할 수 있을 뿐만 아니라 생산성과 유지보수 향상, 패러다임의 불일치 해결, 성능 강화, 데이터 접근 추상화와 벤더 독립성, 표준 등의 부가적인 장점이 있다.

<br>

<br>

### Section 02 JPA 시작
> JPQL이란 무엇이며, SQL과 어떤 차이점이 있는지에 대해 설명해보세요.

JPQA은 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리이다.
SQL을 추상화했기 때문에 특정 데이터베이스 SQL에 의존하지 않는다.

<br>

<br>

### Section 03 영속성 관리
> EntityManagerFactory와 EntityManager에 대해 설명하세요.

EntityManagerFactory는 EntityManager을 생성하는 인터페이스이다. EntityManager는 커넥션 풀에 저장된 영속성 컨텍스트를 요청에 맞게 가져와 접근할 수 있도록 도와준다.

<br>

> 영속성 컨텍스트란 무엇인가요? 영속성 컨텍스트의 이점에 대해서 함께 설명해주세요.

영속성 컨텍스트는 엔티티를 영구 저장하는 환경을 의미한다. 눈에 보이지 않는 논리적인 개념으로 엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있다.

영속성 컨텍스트의 이점은 다음과 같다.
1. 1차 캐시
2. 동일성(identity) 보장
3. 트랜잭션을 지원하는 쓰기 지연(Transactional Write-behind)
4. 변경 감지(Dirty Checking)
5. 지연 로딩(Lazy Loading)

<br>

> 엔티티의 생명주기에 대해 자세히 설명하세요.

- 비영속 (new/transient) : 영속성 컨텍스트와 전혀 관계 없는 새로운 상태
- 영속 (managed) : 영속성 컨텍스트에 관리되는 상태
- 준영속 (detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 (removed) : 삭제된 상태

<br>

> Flush란 무엇이며 영속성 컨텍스트를 Flush하는 방법 3가지에 대해 설명하세요.

`Flush`는 영속성 컨텍스트의 변경 내용을 DB에 반영하는 명령어이다.
Flush 방법은 다음과 같다.
1. `em.flush()` : 직접 호출
2. 트랜잭션 커밋 : 플러시 자동 호출
3. JPQL 쿼리 실행 : 플로시 자동 호출

<br>

<br>

### Section 04 엔티티 매핑
> 엔티티 매핑에 사용되는 어노테이션들을 나열하세요.

- 객체와 테이블 매핑: `@Entity`, `@Table`
- 필드와 컬럼 매핑: `@Column`
- 기본 키 매핑: `@Id`
- 연관관계 매핑: `@ManyToOne`, `JoinColumn`

<br>

> 데이터베이스 스키마 자동 생성 속성 5가지와 생성 속성 사용 시 주의점을 설명하세요.

- `create`: 기존 테이블 삭제 후 다시 생성
- `create-drop`: create와 같으나 종료 시점에 테이블 drop
- `update`: 변경분만 반영 -> 운영 DB에는 사용 X
- `validate` : 엔티티와 테이블이 정상 매핑되었는지만 확인
- `none`: 사용하지 않음

운영 장비에는 절대 create, create-drop, update를 사용하면 안된다.
- 개발 초기 단계: create, update
- 테스트 서버: update, validate
- 스테이징과 운영 서버: validate 또는 none

<br>

> `@Temporal`, `@Enumerated`, `@Lob`, `@Transient`에 대해 설명하세요.

- `@Temporal` : 날짜 타입 매핑
- `@Enumerated` : enum 타입 매핑
- `@Lob` : BLOB, CLOB 매핑
- `@Transient` : 특정 필드를 컬럼으로 매핑하지 않음(매핑 무시)


<br>

> `@GeneratedValue`의 전략 종류를 설명하세요.

- `IDENTITY` : 데이터베이스에 위임 (MYSQL)
- `SEQUENCE` : 데이터베이스 시퀀스 오브젝트 사용(ORACLE)
- `TABLE` : 키 생성용 테이블 사용, 모든 DB에서 사용
- `AUTO` : 방언에 따라 자동 지정

<br>

<br>

### Section 05 연관관계 매핑 기초
> JPA의 양방향 매핑 규칙과 양방향 연관관계에서 주의할 점에 대해 설명하세요.

양방향 매핑 규칙
- 객체의 두 관계 중 하나를 연관관계의 주인으로 지정한다.
- 연관관계의 주인만 외래 키를 관리한다. (등록, 수정)
- 주인이 아닌 쪽은 읽기만 가능하다.
- 주인이 아닌 쪽은 mappedBy 속성으로 주인을 지정한다.

순수 객체 상태를 고려해서 항상 양쪽에 값을 설정해야 함을 주의하자.

<br>

<br>

### Section 07. 고급 매핑
> 상속관계를 매핑하는 방법에 대해 설명하시오.

관계형 데이터베이스에는 상속 관계가 없고 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다. 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법은 3가지가 있다.
1. 각각 테이블로 변환해 조인하는 전략
2. 통합 테이블로 변환해 단일 테이블로 관리하는 전략
3. 서브타입 테이블로 변환해 구현 클래스마다 테이블을 짜는 전략

주요 어노테이션은 다음과 같다.
- `@Inheritance(strategy=InheritanceType.XXX)
  - JOINED
  - SINGLE_TABLE
  - TABLE_PER_CLASS
- `@DiscriminatorColumn(name="DTYPE")`
- `@DiscriminatorValue("XXX")`

<br>

> 조인 전략의 장단점에 대해 설명하시오.

장점
- 테이블 정규화
- 외래 키 참조 무결성 제약조건 활용 가능
- 저장공간 효율화

단점
- 조회시 조인을 많이 사용, 성능 저하
- 조회 쿼리가 복잡함
- 데이터 저장시 INSERT SQL 2번 호출

<br>

> 단일 테이블 전략의 장단점에 대해 설명하시오.

장점
- 조인이 필요 없어 조회 성능이 빠름
- 조회 쿼리가 단순함

단점
- 자식 엔티티가 매핑한 컬럼은 모두 Null 허용
- 단일 테이블이 커져 상황에 따라 조회 성능이 오히려 느려질 수 있음

<br>

> 구현 클래스마다 테이블 전략의 장단점에 대해 설명하시오.

장점
- 서브 타입을 명확히 구분해서 처리할 때 효과적
- Not Null 제약조건 사용 가능

단점
- 전문가가 추천하지 않는 전략
- 여러 자식 테이블을 함께 조회할 때 성능이 느림 (UNION SQL 필요)
- 자식 테이블을 통합해 쿼리하기 힘듬

> `@MappedSuperClass`에 대해 설명하시오.

id, name 등 공통 매핑 정보가 필요할 때 사용한다. 조회나 검색이 불가능하며 직접 생성해 사용할 일이 없으므로 추상 클래스를 권장한다.

<br>

<br>

### Section 08 프록시와 연관관계 관리
> 프록시의 특징에 대해 설명하고, 어떻게 프록시 객체를 사용할 수 있는지 답해보세요.

프록시는 데이터베이스 조회를 미루기 위해 사용하는 가짜 엔티티 객체이다. 실제 클래스를 상속받아 만들어져 실제 클래스와 겉모양이 같다. 그러므로 사용하는 입장에서는 진짜와 프록시 객체를 구분하지 않고 사용한다. 프록시 객체는 실제 객체의 참조를 보관하고, 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다. `em.getReference()` 메소드로 프록시 객체 조회가 가능하다.

<br>

> 즉시 로딩과 지연 로딩에 대해 설명하세요.

- 즉시 로딩: 연관관계에 있는 객체를 즉시 함께 조회한다.
- 지연 로딩: 연관관계에 있는 객체를 프록시 객체로 조회하고, 실제 필요 시 진짜 객체를 조회한다.

즉시 로딩은 N+1문제를 일으키므로 가급적 지연 로딩만 사용한다.

<br>

> CASCADE 종류에 대해 설명하세요.

특정 엔티티를 영속 상태로 만들 때 연관 엔티티도 함께 영속 상태로 만들고 싶을 때 영속성 전이의 용도로 사용한다.

종류
- ALL: 모두 적용
- PERSIST: 영속
- REMOVE: 삭제
- MERGE: 병합
- REFRESH: REFRESH
- DETACH: DETACH

<br>

> 고아 객체에 대해 설명하세요.

고아 객체란 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 말한다.


<br>

<br>

### Section 09 값 타입
> 임베디드 타입의 개념과 사용방법에 대해 설명하세요.

새로운 값 타입을 직접 정의하는 것을 말한다. 주로 기본 값 타입을 모아 만들어 복합 값 타입이라고 하기도 한다. `@Embeddable`을 값 타입을 정의하는 곳에 표시하고 `@Embedded`를 값 타입을 사용하는 곳에 표시한다.

<br>

> '@AttributeOverride'가 무엇인지 설명하세요.

한 엔티티에서 같은 값 타입을 사용할 때 컬럼명이 중복되는 문제를 `@AttributeOverride`를 사용해 컬럼명을 재정의하여 해결할 수 있다.

<br>

> 동일성 비교와 동등성 비교를 비교해 설명하세요.

- 동일성(identity) 비교: 인스턴스의 참조 값을 비교한다.(==)
- 동등성(equivalence) 비교: 인스턴스의 값을 비교한다. (`equals()`)

<br>

> 값 타입 컬렉션을 저장할 때 사용하는 어노테이션들을 설명하세요.

`@ElementCollection`, `@CollectionTable`

<br>

> 값 타입 컬렉션에는 어떤 제약사항이 있고, 실무에서는 이 제약사항을 어떤 방식으로 해결하고 있나요?

값 타입 컬렉션에 변경 사항이 발생하면 모든 연관 데이터를 삭제하고, 다시 저장하므로 실무에서는 상황에 따라 값 타입 컬렉션 대신 일대다 관계를 고려한다. (값 타입은 식별자 개념이 없어 변경 시 추적이 어렵기도 하다.)

<br>

<br>

### Section 10 객체지향 쿼리 언어
> TypeQuery와 Query의 차이점을 설명하세요.

- TypeQuery: 반환 타입이 명확할 때 사용
- Query: 반환 타입이 명확하지 않을 때 사용

<br>

> JPQL의 한계점에 대해 설명하세요.

FROM 절의 서브 쿼리가 현재 불가능하다.
(조인으로 풀 수 있으면 풀어서 해결 가능하다.)

<br>

> case, coalesce, nullif 식에 대해 설명하세요.

- case : 조건에 따라 다른 값을 출력할 수 있다. (c언어의 switch문)
- coalesce : 하나씩 조회해서 null이 아니면 반환
- nullif: 두 값이 같으면 null을, 다르면 첫 번째 값을 반환

<br>

> 페치 조인에 대해 일반 조인과 비교하며 설명하세요.

페치 조인은 SQL에서 지원하지 않는 조인으로 JPQL에서 성능 최적화를 위해 제공하는 기능이다. 연관된 엔티티, 컬렉션을 SQL 한번에 함께 조회 가능하다. (일반 조인은 실행 시 연관 엔티티를 함께 조회하지 않는다.)

<br>

> 페치 조인의 한계에 대해 말씀하세요.

- 조인 대상에 별칭을 줄 수 없다.
- 둘 이상의 컬렉션을 페치 조인할 수 없다.
- 페이징 API를 사용할 수 없다.

<br>

> jpql에서 type과 treat에 대해 설명하세요.

- type: 조회 대상을 특정 자식으로 한정
- treat: 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용

<br>

> Named 쿼리가 무엇인가요?

미리 정의해서 이름을 부여해두고 사용하는 JPQL이다. 애플리케이션 로딩 시점에 쿼리를 검증한다.

<br>

> 벌크 연산에 대해 설명하세요.

쿼리 한 번으로 여러 테이블의 로우를 변경할 수 있다. (`executeUpdate()`가 영향을 받은 엔티티 수를 반환한다.)
영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다.
