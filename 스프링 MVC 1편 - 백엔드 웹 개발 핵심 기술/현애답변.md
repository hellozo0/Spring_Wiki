## Section 01. 웹 어플리케이션 이해
> 웹 서버와 웹 어플리케이션 서버(WAS)의 차이점에 대해 말해보세요.

- 웹 서버(Web Server)
정적인 리소스(HTML, CSS, jS, 이미지, 영상 등)를 네트워크망에 종속되지 않고 제공할 수 있도록 하는 웹 어플리케이션을 말합니다. (ex: NGINX, APACHE)
 
- 웹 어플리케이션 서버(WAS)
HTTP를 통해 동적인 서버 콘텐츠(애플리케이션 로직)를 수행한다. 웹 서버와 함께 JSP와 Servlet을 실행시킬 수 있는 소프트웨어인 웹 컨테이너를 함께 올려놓고 사용한다.

<br>

> 서블릿 컨테이너란?

톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 부른다. 서블릿 컨테이너는 서블릿 객체의 생성, 초기화, 호출, 종료라는 생명주기를 관리한다. 서블릿 객체는 싱글톤으로 미리 만들어져 모든 고객의 요청이 동일한 서블릿 객체 인스턴스에 접근하도록 한다. 동시 요청을 위한 멀티 쓰레드 처리를 지원한다.


<br>

> 쓰레드와 멀티 쓰레드에 대해 설명해보세요.

애플리케이션 코드를 하나하나 순차적으로 실행하는 것을 쓰레드라고 말한다.
ex) 자바 메인 메서드를 처음 실행하면 `main` 쓰레드가 실행됨.


<br>

> 쓰레드 풀의 특징과 장점은?

다중 스레드의 비용이 매우 비싸다는 점을 해결하기 위해 고안되었다.

- 쓰레드 풀의 역할
  - 필요한 쓰레드들을 쓰레드 풀에 보관하고 관리한다. 
  - 생성 가능한 쓰레드의 최대치를 관리한다. (톰캣의 기본값: 200개)
- 쓰레드 사용 방법
  - 쓰레드 필요 시, 이미 생성되어 있는 쓰레드를 쓰레드 풀에서 꺼내 사용한다.
  - 사용을 종료하면 쓰레드 풀에 해당 쓰레드를 반납한다.
  - 쓰레드 풀에 쓰레드가 없으면 요청을 거절하거나 대기하도록 설정한다.
- 장점
  - 쓰레드의 생성, 종료 비용이 절약되고 응답 시간이 빠르다.
  - 생성 가능한 쓰레드 최대치가 정해져 있어 많은 요청이 들어와도 대응할 수 있다.
  
쓰레드 풀의 최대치 값에 대한 적정 숫자는 성능 테스트를 통해 알 수 있다.
ex: 아파치 ab, Jmeter, nGrinder


<br>

> SSR과 CSR에 대해 설명해주세요.
- SSR - 서버 사이드 렌더링
  - 서버에서 HTML 최종 결과를 만들어 웹 브라우저에게 전달한다.
  - 주로 정적인 화면에 사용한다.
  - ex: JSP, Thymeleaf
- CSR - 클라이언트 사이드 렌더링
  - HTML 결과를 자바스크립트로 웹 브라우저에서 동적 적용한다.
  - 주로 동적인 화면에 사용한다.
  - ex: React, Vue.js


<br>

<br>

## Section 02 서블릿
> HttpServletRequest와 HttpServletResponse의 역할이 무엇인가요?

개발자가 HTTP 요청 메시지, 응답 메시지를 편리하게 사용할 수 있도록 서블릿이 HTTP 요청과 응답 메시지를 파싱해 제공한다.
  

<br>

<br>

## Section 03 서블릿, JSP, MVC 패턴

> MVC 패턴이란 무엇이며 서블릿과 JSP의 어떤 문제점을 해결하나요?

JSP 파일을 보면 상위 절반은 비즈니스 로직을, 나머지 하위 절반만 HTML 뷰 로직을 갖고 있다. 게다가 JSP 코드에 자바의 데이터를 조회하는 코드들이 노출되어 있다. JSP가 너무 많은 역할을 담당해 유지보수가 힘들어진다.
-> 특히 비즈니스 로직과 뷰 로직의 변경 라이프 사이클이 다르다는 점이 가장 큰 문제이다.

이렇게 섞여 있는 비즈니스 로직과 뷰 로직을 분리하기 위해 MVC(Model View Controller) 패턴이 등장했다. 비즈니스 로직은 서블릿처럼 Controller가 처리하고, JSP는 뷰를 그리는 영역에만 집중하도록 한다.

- 컨트롤러
  - HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행한다.
  - 뷰에 전달할 결과 데이터를 조회해서 모델에 담는다.
- 모델
  - 뷰에 출력할 데이터를 담아둔다.
- 뷰
  - 비즈니스 로직이나 데이터 접근을 몰라도 되고, 화면을 렌더링하는 일에만 집중한다.

<br>

> redirect VS forward

- redirect: 실제 클라이언트에 응답이 나갔다가, 클라이언트가 redirect 경로로 다시 요청한다.
- forward: 서버 내부에서 일어나는 호출이므로 클라이언트가 전혀 인지하지 못한다.


<br>

> MVC 패턴의 한계에 대해 이야기 해보세요, 그 한계를 보완할 수 있는 디자인 패턴이 있을까요? 있다면 해당 패턴에 대해 설명해주세요

한계 1. 컨트롤러에 뷰를 이동하거나 뷰 경로에 대한 중복 코드가 많다.
한계 2. `HttpServletRequest, HttpServletResponse`는 사용하지 않는 경우가 잦다.
한계 3. 컨트롤러에서 공통으로 처리해야 하는 부분을 다루기가 어렵다.

이 한계들은 프론트 컨트롤러 패턴을 통해 해결할 수 있다. 패턴 특징은 다음과 같다.
프론트 컨트롤러 서블릿 하나로 클라이언트 요청을 받는다. 프론트 컨트롤러는 요청에 맞는 컨트롤러를 찾아서 호출하는 역할을 수행한다. 요청이 들어올 수 있는 입구는 프론트 컨트롤러 단 하나이고, 프론트 컨트롤러에서 공통 기능들을 처리할 수 있다. 나머지 컨트롤러들은 서블릿을 사용하지 않아도 된다.

스프링 웹 MVC도 `DispatcherServlet`과 `FrontController` 패턴으로 이루어져있다.

<br>

<br>

## Section 04 MVC 프레임워크 만들기
> 어댑터 패턴이란?

다양한 전압의 콘센트를 번갈아가며 사용해야 하듯이 한 클래스에서 여러 인터페이스를 호환해 사용해야 하는 경우 적용할 수 있는 패턴이다. 다양한 종류의 인터페이스와 주 클래스 사이에 어댑터 클래스를 하나 만들어 인터페이스를 호환해 사용할 수 있도록 한다.

<br>

> 핸들러와 핸들러 어댑터란?

- 핸들러 어댑터: 핸들러와 Front Controller 사이에서 어댑터 역할을 수행해 다양한 종류의 컨트롤러를 호출할 수 있도록 한다.
- 핸들러: 컨트롤러와 같이 클라이언트의 요청에 따라 주어진 역할을 수행하는 클래스이다.


<br>

<br>


## Section 05 스프링 MVC - 구조 이해
> Spring MVC의 DispatcherServlet 구조와 요청 흐름을 설명해주세요.

`DispatcherServlet`은 Spring MVC에서 프론트 컨트롤러의 역할을 수행한다.
동작 순서는 다음과 같다.
1. 클라이언트가 HTTP 요청을 보내면 DispatcherServlet이 가장 먼저 요청을 받는다.
2. 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러를 조회한다.
3. 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.
4. 핸들러 어댑터를 실행한다.
5. 핸들러 어댑터는 핸들러가 반환하는 정보를 `ModelAndView`로 변환해서 반환한다.
6. `viewResolver`를 찾아 실행한다.
7. `viewResolver`는 뷰의 논리 이름을 물리 이름으로 바꾸고, 렌더링 역할을 담당하는 뷰 객체를 반환한다.
8. 뷰 객체를 통해 뷰를 렌더링한다.

<br>

> 뷰 리졸버의 역할은?

뷰의 논리 이름을 물리 이름으로 바꾸고 해당 뷰 객체를 찾아 반환하는 역할을 수행한다.
스프링 부트는 기본적으로 `BeanNameViewResolver`와 `InternalResourceViewResolver`를 자동 등록한다.

<br>

> 컨트롤러에서 Model 파라미터는 어떤 역할을 수행하나요?

컨트롤러에서 뷰에게 전달하고 싶은 데이터를 담는 역할을 수행한다.
모델에 뷰에게 필요한 데이터들을 저장해두기 때문에 뷰는 렌더링에만 집중할 수 있다.

<br>

<br>

## Section 06 스프링 MVC - 기본 기능

> 스프링 부트 로깅 방법과 로깅의 장점에 대해 설명해주세요.

실무에서는 `Logback`을 대부분 사용한다.

로그 선언 방법은 3가지가 있다.
- `private Logger log = LoggerFactory.getLogger(getClass());`
- `private static final Logger log = LoggerFactory.getLogger(Xxx.class);`
- `@Slf4j`

로그를 사용했을 때의 장점은 다음과 같다.
- 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.
- 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고, 운영 서버에서는 출력하지 않는 등 로그를 상황에 맞게 조절할 수 있다.
- 시스템 아웃 콘솔 뿐만 아니라 파일 네트워크 등 별도 위치에 로그를 남길 수 있다.
- `System.out`보다 성능이 좋다.

<br>

> 요청으로 `keyA=value1&keyA=value2`처럼 하나의 키에 여러 값이 들어왔을 때 어떤 파라미터 타입을 사용하나요?

`MultiValueMap`을 사용하면 하나의 키에 여러 값을 받을 수 있다. Header 또는 Query Parameter에서 하나의 키에 여러 값을 받고 싶을 때 사용한다.

<br>

> 스프링 부트의 주요 메시지 컨버터 종류를 설명해주세요.

스프링 부트에서는 기본적으로 다음 세가지의 메시지 컨버터를 지원한다.
1. `ByteArrayHttpMessageConverter`
2. `StringHttpMessageConverter`
3. `MappingJackson2HttpMessageConverter`

<br>

> Controller의 파라미터에서 HttpEntity는 어떤 경우에 사용하나요?

HTTP Header와 Body 정보를 편리하게 조회할 수 있다. 요청 뿐만 아니라 응답에도 바디 정보를 직접 반환하거나 헤더 정보를 포함하고 싶을 때 사용할 수 있다.

<br>

> `@ModelAttribute`는 어떤 역할을 수행하나요?

스프링 MVC는 해당 파라미터 타입의 객체를 생성하고 그 프로퍼티의 수정자를 호출해 파라미터 값들을 객체에 자동으로 바인딩한다.

<br>

<br>

## Section 07 스프링 MVC - 웹 페이지 만들기

> 상품 등록 폼에서 데이터를 입력하고 저장 버튼을 누르면 POST API를 수행합니다. 여기서 새로 고침을 또 선택하면 다시 POST API를 수행해 상품을 두 번 등록하게 됩니다. 이 문제는 어떻게 해결할 수 있을까요?

상품 저장 후에 뷰 템플릿으로 이동하지 않고 상품 상세 화면으로 리다이렉트를 호출하면 된다.
마지막에 호출한 내용이 상품 상세 화면의 GET API이므로 새로 고침을 해도 문제가 발생하지 않는다.

<br>

