## 실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발

### Section 6. 주문 도메인 개발
> 도메인 모델 패턴이란?

엔티티가 비즈니스 로직을 가지고 객체 지향의 특성을 적극 활용하는 패턴이다. 예를 들어 주문 서비스의 주문과 주문 취소 메서드가 주문 엔티티 내부에 있는 경우가 있다.

<br>

> 트랜잭션 스크립트 패턴이란?

엔티티에는 비즈니스 로직이 거의 없고 서비스 계층에서 대부분의 비즈니스 로직을 처리하는 것을 말한다.

<br>

<br>

### Section 7. 웹 계층 개발
> 준영속 엔티티에 대한 병합 동작 방식을 간단히 설명해보세요.

준영속 엔티티란 영속성 컨텍스트가 더는 관리하지 않는 엔티티를 말합니다. 준영속 엔티티를 수정하는 방법으로 1. 변경 감지 기능을 사용하거나 2. 병합을 사용하는 방법이 있습니다.

병합이 동작하는 방식은 다음과 같습니다.
1. `merge()`를 실행한다.
2. 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회한다.
2-1. 만약 1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고, 1차 캐시에 저장한다.
3. 조회한 영속 엔티티에 준영속 엔티티의 값을 채워 넣는다.
4. 영속 상태인 엔티티를 반환한다.

<br>

> repository의 `save()` 메서드가 수행하는 두 가지 동작을 설명하세요.

`save()` 하나로 저장과 수정(병합)을 다 처리할 수 있습니다. 식별자 값이 없으면 새로운 엔티티로 판단해서 `persist()`로 영속화하고, 만약 식별자 값이 있으면 이미 한번 영속화되었던 엔티티로판단해 `merge()`로 수정(병합)합니다.

<br>

<br>

## 실전! 스프링 부트와 JPA 활용2 - API 개발과 성능 최적화

### Section 01 API 개발 기본
> 컨트롤러 메소드에서 파라미터와 리턴 값으로 DTO를 사용하는 이유가 무엇인가요?

엔티티를 직접 Request/Response Body와 매핑하면 엔티티에 프레젠테이션 계층을 위한 로직이 추가됩니다. 엔티티에 API 검증을 위한 로직이 들어가고, 한 엔티티에 대해 각각의 API를 위한 모든 요구사항을 담기는 어렵습니다. 엔티티가 변경될 때마다 API 스펙이 변합니다. 그러므로 API 스펙에 맞춰 별도의 DTO를 파라미터 또는 리턴 값으로 사용합니다.

<br>

<br>

### Section 02 API 개발 고급 - 준비
> 지연 로딩으로 엔티티로 조회해 DTO로 변환하면 쿼리는 평균적으로 총 몇 번 실행되나요?

평균적으로 지연로딩을 엔티티를 조회하여 DTO로 변환하는 경우에는 엔티티 조회에 1번, 지연 로딩으로 하나의 연관 관계를 조회하는데에 N번이 발생합니다. 연관관계가 두 개인 경우에는 1 + 2N 번의 쿼리가 실행됩니다.

<br>

> JPA에서 DTO로 바로 조회할 때의 장단점은 무엇인가요?

원하는 값을 선택해서 조회하기 때문에 DB에서 애플리케이션으로까지 네트워크 용량을 미비하지만 최적화할 수 있습니다. 그러나 리포지토리의 재사용성이 떨어지고, API 스펙에 맞춰진 코드가 리포지토리에 들어간다는 단점이 있습니다.

우선 엔티티를 DTO로 변환하는 방법을 선택하고, 필요 시에 페치 조인으로 성능을 최적화합니다. 그래도 안되면 DTO로 직접 조회하는 방법을 사용합니다. 최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해 SQL을 직접 사용합니다.

<br>

<br>

### Section 03 API 개발 고급 - 지연 로딩과 조회 성능 최적화
> 컬렉션 페치 조인의 장단점은 무엇인가요?

N+1번의 쿼리를 1번으로 줄일 수 있습니다. 그러나 페이징이 불가능하다는 단점이 있습니다.

<br>

> 페이징으로 컬렉션 엔티티를 함께 조회하려면 어떻게 성능을 최적화해야 할까요?

1. ToOne 관계는 모두 페치 조인을 사용합니다.
2. 컬렉션은 지연 로딩으로 조회합니다.
3. 지연 로딩의 성능 최적화를 위해 `hibernate.default_batch_fetch_size`, `@BatchSize`를 적용합니다.

이렇게 할 경우, 쿼리 호출 수가 1+N개 에서 1+1개로 최적화됩니다.


<br>

<br>

### Section 04 API 개발 고급 - 컬렉션 조회 최적화
> DTO 조회 방식 3가지에 대해 설명하고, 각 장단점을 이야기해보세요.

1. 루트를 1번 조회하고, 연관관계의 컬렉션을 N번 조회합니다. 
2. 루트를 1번 조회하고, 연관관계의 컬렉션을 1번 조회합니다.
3. 필요한 연관관계를 모두 조인하여 1번의 쿼리로 조회합니다. (중복 데이터 추가, 페이징 불가능)

상황에 따라 3가지 조회 방식이 모두 다른 성능을 보여주기 때문에 적절히 선정해 사용해야 합니다.

<br>

<br>

### Section 05 API 개발 고급 - 실무 필수 최적화
> OSIV란 무엇인가요?

OSIV는 Open Session In View의 약자로, 하이버네이트를 말합니다. OSIV 전략은 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날 때까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지합니다. 그래서 View Template이나 API 컨트롤러에서 지연 로딩이 가능하도록 합니다.

 이 전략은 너무 오랜 시간 동안 DB 커넥션 리소스를 사용하기 때문에 실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자라 장애로 이어질 수 있습니다.
 
 OSIV를 끄면 모든 지연로딩을 트랜잭션 안에서 처리해야 합니다. 그러므로 실무에서는 OSIV를 끈 상태로 Command와 Query를 분리해 복잡성을 관리합니다. 크고 복잡한 애플리케이션을 개발한다면, 이 둘의 관심사를 명확하게 분리하는 선택은 유지보수 관점에서 의미가 있습니다.

ex) OrderService -> OrderService(핵심 비즈니스 로직) + OrderQueryService(화면, API에 맞춘 읽기 전용 트랜잭션 서비스)

<br>

